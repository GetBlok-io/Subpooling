{
  val shareState = SELF.R4[AvlTree].get
  val maxScore   = SELF.R5[Int].get


  val rewardBox  = INPUTS(1)

  val initialValue  = rewardBox.R4[Long].get

  val stateUpdates  = getVar[Coll[(Coll[Byte], Coll[Byte])]](0).get
  val proof         = getVar[Coll[Byte]](1).get

  val keys          = stateUpdates.map{ (kv: (Coll[Byte], Coll[Byte])) => kv._1}

  val paymentBoxes: Coll[Box] = OUTPUTS.slice(2, keys.size + 2)
  val totalPaid    = paymentBoxes.fold(0L, { (z: Long, box: Box) => z + box.value })

  // val validReward = SELF.tokens(0)._1 == rewardBox.tokens(0)._1

  val oldScores   = shareState.getMany(keys, proof)

  val validStateTransition = keys.forall{
    (key: Coll[Byte]) =>
      val index =   keys.indexOf(key, 0)
      val output = OUTPUTS(index + 2)
      val oldScoreState: Coll[Byte]  = oldScores(index).get
      val updated: Coll[Byte]   = stateUpdates(index)._2

      val oldScoreBytes = updated.slice(0, 8)

      val shareScore = byteArrayToLong( oldScoreBytes )
      val paymentIsValid = output.value == (shareScore * initialValue) / maxScore.toLong
      val wasNotPaid     = oldScoreState.slice(8, 9)(0) == 0.toByte
      val isNowPaid      = updated.slice(8, 9)(0) == 1.toByte
      val scoresAreEqual = shareScore == byteArrayToLong(updated.slice(0, 8))
      val boxIsCorrect   = blake2b256(output.propositionBytes) == key
      allOf(Coll(
        paymentIsValid,
        wasNotPaid,
        isNowPaid,
        scoresAreEqual,
        boxIsCorrect
      ))

  }
  val nextShareState  = shareState.update(stateUpdates, proof).get
  val nextRewardValid = OUTPUTS(1).value == rewardBox.value - totalPaid
  val nextShareStateValid = OUTPUTS(0).R4[AvlTree].get.digest == nextShareState.digest

  val validSpend = allOf(
    Coll(
      nextRewardValid,
      nextShareStateValid,
      validStateTransition,
    )
  )
  sigmaProp(validSpend)
}