{
  val balanceStateExists = SELF.R4[AvlTree].isDefined
  val nextBalanceState = OUTPUTS(0).R4[AvlTree].isDefined


  sigmaProp(nextBalanceState)
//  val rewardBox  = INPUTS(1)
//
//  val initialValue  = rewardBox.R4[Long].get
//
//  val stateData     = getVar[Coll[(Coll[Byte], Coll[Byte])]](0).get
//  val proof         = getVar[Coll[Byte]](1).get
//  val commandBytes  = getVar[Coll[Byte]](2).get
//
//  val insertCommand = Coll(0.toByte)
//  val updateCommand = Coll(1.toByte)
//  val payoutCommand = Coll(2.toByte)
//  val keys          = stateData.map{ (kv: (Coll[Byte], Coll[Byte])) => kv._1}
//  val insertMiners = {
//    if(commandBytes == insertCommand){
//
//      val emptyInserts = stateData.forall{
//        (keyVal: (Coll[Byte], Coll[Byte])) =>
//          val balance = byteArrayToLong(keyVal._2.slice(0, 8))
//          balance == 0L
//      }
//      val nextState = balanceState.insert(stateData, proof).get
//      val validStateTransition = nextBalanceState.digest == nextState.digest
//
//      val validInsertion = allOf(
//        Coll(
//          emptyInserts,
//          validStateTransition,
//          SELF.value == OUTPUTS(0).value
//        )
//      )
//
//      validInsertion
//    }else{
//      false
//    }
//  }
//
//  val updateBalances = {
//    if(commandBytes == updateCommand){
//
//      // val validReward = SELF.tokens(0)._1 == rewardBox.tokens(0)._1
//
//      val oldBalances   = balanceState.getMany(keys, proof)
//      val totalPaid     = stateData.fold(0L, { (z: Long, keyVal: (Coll[Byte], Coll[Byte])) =>
//        val minerBalanceChange: Long = byteArrayToLong( keyVal._2.slice(0, 8) )
//        z + minerBalanceChange
//       }
//      )
//
//      val newBalances: Coll[(Coll[Byte], Coll[Byte])] = stateData.map{
//        (keyVal: (Coll[Byte], Coll[Byte])) =>
//          val index =   keys.indexOf(keyVal._1, 0)
//          val oldMinerBalance: Coll[Byte]      = oldBalances(index).get
//          val balanceChangeBytes: Coll[Byte]   = keyVal._2
//
//          val lastBalance = byteArrayToLong( oldMinerBalance )
//          val minerBalanceChange = byteArrayToLong( balanceChangeBytes )
//          val nextBalance = minerBalanceChange + lastBalance
//
//          (keyVal._1, longToByteArray( nextBalance ))
//      }
//
//      val updatedBalanceState  = balanceState.update(newBalances, proof).get
//      val nextRewardValid = nextStateBox.value == SELF.value + totalPaid
//      val nextBalanceStateValid = nextBalanceState.digest == updatedBalanceState.digest
//
//      val validUpdate = allOf(
//        Coll(
//          nextRewardValid,
//          nextBalanceStateValid
//        )
//      )
//      validUpdate
//    }else{
//      false
//    }
//  }
//
//  val payoutBalances = {
//      if(commandBytes == payoutCommand){
//
//        // val validReward = SELF.tokens(0)._1 == rewardBox.tokens(0)._1
//
//        val oldBalances   = balanceState.getMany(keys, proof)
//        val totalPaid     = oldBalances.fold(0L, {
//        (z: Long, balance: Option[Coll[Byte]]) =>
//          val minerBalance: Long = byteArrayToLong( balance.get )
//          z + minerBalance
//         }
//        )
//
//        val validStateTransition: Coll[(Coll[Byte], Coll[Byte])] = stateData.forall{
//          (keyVal: (Coll[Byte], Coll[Byte])) =>
//            val index =   keys.indexOf(keyVal._1, 0)
//            val oldMinerBalance: Coll[Byte]      = oldBalances(index).get
//            val balanceChangeBytes: Coll[Byte]   = keyVal._2
//            val output = OUTPUTS(1 + index)
//
//            val lastBalance = byteArrayToLong( oldMinerBalance )
//            val nextBalance = byteArrayToLong( balanceChangeBytes )
//
//            val paymentIsValid = output.value == lastBalance
//            val balanceReset = nextBalance == 0L
//            val boxIsCorrect = blake2b256( output.propositionBytes ) == keyVal._1
//
//            allOf(
//              Coll(
//                paymentIsValid,
//                balanceReset,
//                boxIsCorrect
//              )
//            )
//        }
//
//        val updatedBalanceState  = balanceState.update(stateData, proof).get
//        val nextRewardValid = nextStateBox.value == SELF.value - totalPaid
//        val nextBalanceStateValid = nextBalanceState.digest == updatedBalanceState.digest
//
//        val validPayout = allOf(
//          Coll(
//            validStateTransition,
//            nextRewardValid,
//            nextBalanceStateValid
//          )
//        )
//        validPayout
//      }else{
//        false
//      }
//    }



  // sigmaProp(insertMiners || updateBalances || payoutBalances)
}