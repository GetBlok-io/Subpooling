{
  // Hybrid Exchanged Emissions - Kirat Singh
  // This contract takes a PORTION of the block reward (in INPUTS(1)), removes a fee from it, and
  // then performs a simulated swap and adjusts the output using the given percentage value.
  // This output value represents the tokens taken from the emission box, and represents the
  // tokens in the miner's payout.

  // Constants
  val shareOperator: SigmaProp  = const_shareOpPK
  val poolOperator:  SigmaProp  = const_poolOpPK
  val LPToken:       Coll[Byte] = const_LPTokenId
  val distToken:     Coll[Byte] = const_distTokenId
  val holdingBytes:  Coll[Byte] = const_holdingBytesHashed
  val slippage:      Int        = 1 // Assume 1% slippage

  val standardDenom:  Long       = 100000L          // Standard denominator used
  // SELF Assets & Registers
  val emToken:       Coll[Byte]  = SELF.tokens(0)._1 // emission NFT
  val distTokenAmnt: Coll[Byte]  = SELF.tokens(1)._2
  val percentChange: Long        = SELF.R4[Long].get // percent added
  val poolFee:       Long        = SELF.R5[Long].get
  val emissionEpoch: Long        = SELF.R6[Long].get


  // Other Assets & Registers
  val LPBox:  Box                   = CONTEXT.dataInputs(0)
  val feeNum: Int                   = LPBox.R4[Int].get
  val realLPToken:   Coll[Byte]     = LPBox.tokens(0)._1
  val realDistToken: Coll[Byte]     = LPBox.tokens(2)._1
  val assetX:  BigInt               = LPBox.value.toBigInt
  val assetY:  BigInt               = LPBox.tokens(2)._2.toBigInt

  val holdingBox: Box               = OUTPUTS(1)
  val bonusOutput: Long             = holdingBox.R4[Long].get // This number should allow for transparency because the
                                                              // division of normal tokens from extra tokens can be determined

  def isValueInRange(valuesPair: (BigInt, BigInt)): Boolean = {
    val expected = valuesPair._1
    val actual   = valuesPair._2
    val amountTop = (expected - actual) * 100L
    val percentage = amountTop / actual
    (percentage < 1L) && (percentage > -1L) // 1% margin of error during calculations
  }



  val blockReward: Long   = INPUTS(1).value
  // Fee taken before proportioning for swap
  val rewardAfterFees: Long   = blockReward - ((blockReward * (poolFee)) / standardDenom)
  // Reward to simulate swap with, some proportion of the block reward
  // Nitro not included in calculation
  val rewardToSimSwap: Long   = rewardAfterFees

  // Perform simulated swap
  val outputNum    = (assetY * rewardToSimSwap * feeNum)

  val maxAssetX    = (assetX + ((assetX * slippage) / 10000)) * 1000
  val adjustedFee  = rewardToSimSwap * feeNum

  val outputDenom  = (maxAssetX + adjustedFee)

  val outputAmount = (outputNum / outputDenom)

  // Adjust output to add percentage
  val adjustedOutput = (outputAmount + ((outputAmount * percentChange) / standardDenom))

  val totalOutput = adjustedOutput + bonusOutput

  // Boolean Props
  val validLPBox: Boolean = {
    allOf(Coll(
      LPToken == realLPToken,
      distToken == realDistToken
    ))
  }

  val hasNextEmissions: Boolean = {
    allOf(Coll(
      OUTPUTS(0).propositionBytes == SELF.propositionBytes,
      OUTPUTS(0).tokens(0)._1 == emToken,
      OUTPUTS(0).tokens(1)._1 == distToken,
      isValueInRange((OUTPUTS(0).tokens(1)._2.toBigInt, (distTokenAmnt - totalOutput).toBigInt)),
      OUTPUTS(0).value         == SELF.value,
      OUTPUTS(0).R4[Long].get  == percentChange, // Cannot be changed, but kept on registers rather than constants for visibility / transparency
      OUTPUTS(0).R5[Long].get  <= 3000, // Share operator may take max fee of 3000 / 100000 or 3%, and may change every emission cycle
      OUTPUTS(0).R5[Long].get  >= 0,
      OUTPUTS(0).R6[Long].get  == emissionEpoch + 1L,
      emissionEpoch >= 0 // Disincentivize share op from setting negative initial epoch to take advantage of exit strategy
    ))
  }

  val outputSwapped = isValueInRange((OUTPUTS(2).value.toBigInt, rewardToSimSwap.toBigInt)) && OUTPUTS(2).propositionBytes == poolOperator.propBytes
  val feeOutputExists = isValueInRange((OUTPUTS(3).value.toBigInt, (blockReward - rewardAfterFees).toBigInt))
  val holdingValid: Boolean = {
    allOf(Coll(
      holdingBox.tokens(0)._1 == distToken,
      isValueInRange((holdingBox.tokens(0)._2.toBigInt, totalOutput.toBigInt)),
      holdingBox.value == 1000000L,
      holdingBytes == blake2b256( holdingBox.propositionBytes ),
      bonusOutput >= 0L
    ))
  }

  // Exit strategy:
  // if epoch is < 5L, share op may initiate exit strategy, where all tokens go to pool op.
  // Intended to help with initial launches in case of mistakes :)
  // May be initiated by either share op or pool op
  val exitStrategy: SigmaProp = {
    val exitPeriod        = emissionEpoch < 5L && emissionEpoch >= 0
    val tokensTransferred = SELF.tokens(1)._2 == OUTPUTS(0).tokens(0)._2
    val tokenIdsEqual     = SELF.tokens(1)._1 == OUTPUTS(0).tokens(0)._1
    val propBytesValid    = OUTPUTS(0).propositionBytes == poolOperator.propBytes

    val validExit  = allOf(
      Coll(
        exitPeriod,
        tokensTransferred,
        tokenIdsEqual,
        propBytesValid
      )
    )

    sigmaProp( exitStrategy ) && ( shareOperator || poolOperator )
  }

  // Token Emission:
  // Normal token emission, where swap is simulated.
  val tokenEmission: SigmaProp = {
    sigmaProp(validLPBox && hasNextEmissions && holdingValid && outputSwapped && feeOutputExists) && shareOperator
  }

  tokenEmission || exitStrategy
}