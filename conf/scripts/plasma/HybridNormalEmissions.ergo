{
  // Hybrid Normal Emissions - Kirat Singh
  // This contract takes a PORTION of the block reward (in INPUTS(1)), removes a fee from it, and
  // then performs a simulated swap.
  // This output value represents the tokens taken from the emission box, and represents the
  // tokens in the miner's payout.

  // Constants
  val shareOperator: SigmaProp  = const_shareOpPK
  val poolOperator:  SigmaProp  = const_poolOpPK
  val distToken:     Coll[Byte] = const_distTokenId
  val holdingBytes:  Coll[Byte] = const_holdingBytesHashed
  val decimals:      Long       = const_decimals // 1 * 10^8 = 1 Flux token

  val standardDenom: Long       = 100000L          // Standard denominator used
  // SELF Assets & Registers
  val emToken:       Coll[Byte]  = SELF.tokens(0)._1 // emission NFT
  val distTokenAmnt: Coll[Byte]  = SELF.tokens(1)._2

  val poolFee:       Long        = SELF.R4[Long].get
  val proportion:    Long        = SELF.R5[Long].get
  val exitHeight:    Long        = SELF.R6[Long].get

  // Other Assets & Registers
  val holdingBox: Box               = OUTPUTS(1)
  val exRate:     Long              = holdingBox.R4[Long].get


  def isValueInRange(valuesPair: (BigInt, BigInt)): Boolean = {
    val expected = valuesPair._1
    val actual   = valuesPair._2
    val amountTop = (expected - actual) * 100L
    val percentage = amountTop / actual
    (percentage < 1L) && (percentage > -1L) // 1% margin of error during calculations
  }



  val blockReward: Long   = INPUTS(1).value
  // Fee taken before proportioning for swap
  val rewardAfterFees: Long   = blockReward - ((blockReward * (poolFee)) / standardDenom)
  // Reward to simulate swap with, some proportion of the block reward
  // Nitro not included in calculation
  val rewardToSimSwap: Long   = (rewardAfterFees * proportion) / standardDenom

  // Rest of ERG reward to be distributed normally
  val rewardInERG:     Long   = rewardAfterFees - rewardToSimSwap

  // Perform simulated swap
  val outputAmount:   BigInt = (rewardToSimSwap.toBigInt * decimals.toBigInt) / (exRate.toBigInt)


  val hasNextEmissions: Boolean = {
    allOf(Coll(
      OUTPUTS(0).propositionBytes == SELF.propositionBytes,
      OUTPUTS(0).tokens(0)._1 == emToken,
      OUTPUTS(0).tokens(1)._1 == distToken,
      isValueInRange((OUTPUTS(0).tokens(1)._2.toBigInt, (distTokenAmnt - outputAmount).toBigInt)),
      OUTPUTS(0).value         == SELF.value,
      OUTPUTS(0).R4[Long].get  <= 3000, // Share operator may take max fee of 3000 / 100000 or 3%, and may change every emission cycle
      OUTPUTS(0).R4[Long].get  >= 0,
      OUTPUTS(0).R5[Long].get  == proportion,
      OUTPUTS(0).R6[Long].get  == exitHeight
    ))
  }

  val outputSwapped = isValueInRange((OUTPUTS(2).value.toBigInt, rewardToSimSwap.toBigInt)) && OUTPUTS(2).propositionBytes == poolOperator.propBytes
  val feeOutputExists = isValueInRange((OUTPUTS(3).value.toBigInt, (blockReward - rewardAfterFees).toBigInt))
  val holdingValid: Boolean = {
    allOf(Coll(
      holdingBox.tokens(0)._1 == distToken,
      isValueInRange((holdingBox.tokens(0)._2.toBigInt, outputAmount.toBigInt)),
      isValueInRange((holdingBox.value.toBigInt, rewardInERG.toBigInt)),
      holdingBytes == blake2b256( holdingBox.propositionBytes )
    ))
  }

  val validSpend   = sigmaProp(hasNextEmissions && holdingValid && outputSwapped && feeOutputExists) && shareOperator
  val exitStrategy = sigmaProp(HEIGHT < exitHeight && exRate == -1) && shareOperator

  validSpend || exitStrategy

}